# -*- coding: utf-8 -*-
"""Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18FrM7eo20rPL_SH1h-sV0SBBFcJzAxis
"""

# Where 0 denotes the blank tile or space.
goal_state = [1,12,11,10,2,13,0,9,3,14,15,8,4,5,6,7]
#
# The code will read state from a file called "state.txt" where the format is
# as above but space seperated. i.e. the content for the goal state would be
# 1,12,11,10,2,13,0,9,3,14,15,8,4,5,6,7

### Code begins.
import sys
from operator import attrgetter



def display_board(state):
    print( "-------------------------------------")
    print( "|   %i   |   %i   |   %i   |   %i   |" % (state[0], state[4], state[8], state[12]))
    print( "-------------------------------------")
    print( "|   %i   |   %i   |   %i   |   %i   |" % (state[1], state[5], state[9], state[13]))
    print( "-------------------------------------")
    print( "|   %i   |   %i   |   %i   |   %i   |" % (state[2], state[6], state[10], state[14]))
    print( "-------------------------------------")
    print( "|   %i   |   %i   |   %i   |   %i   |" % (state[3], state[7], state[11], state[15]))
    print( "-------------------------------------")

def move_up(state):
    """Moves the blank tile up on the board. Returns a new state as a list."""
    # Perform an object copy
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [0, 4,8,12]:
        temp = new_state[index - 1]
        new_state[index - 1] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move, return None (Pythons NULL)
        return None
def move_down(state):
    """Moves the blank tile down on the board. Returns a new state as a list."""
    # Perform object copy
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [9,7,11,15]:
        # Swap the values.
        temp = new_state[index + 1]
        new_state[index + 1] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move, return None.
        return None



def move_left(state):
    """Moves the blank tile left on the board. Returns a new state as a list."""
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [0, 1, 2,3]:
        # Swap the values.
        temp = new_state[index - 4]
        new_state[index - 4] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move it, return None
        return None
    
def move_right(state):
    """Moves the blank tile right on the board. Returns a new state as a list."""
    # Performs an object copy. Python passes by reference.
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [12,13,14,15]:
       
        # Swap the values.
        temp = new_state[index + 4]
        
        new_state[index + 4] = new_state[index]
        new_state[index] = temp
        
        return new_state
    else:
        # Can't move, return None
        return None
def move_up_left_diagonal(state):
    """Moves the blank tile right on the board. Returns a new state as a list."""
    # Performs an object copy. Python passes by reference.
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [0, 1, 2,3,4,8,12]:
        # Swap the values.
        temp = new_state[index - 5]
        new_state[index - 5] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move, return None
        return None
def move_down_right_diagonal(state):
    """Moves the blank tile right on the board. Returns a new state as a list."""
    # Performs an object copy. Python passes by reference.
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [3,7,11,12,13,14,15]:
        # Swap the values.
        temp = new_state[index + 5]
        new_state[index + 5] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move, return None
        return None
    
def move_up_right_diagonal(state):
    """Moves the blank tile right on the board. Returns a new state as a list."""
    # Performs an object copy. Python passes by reference.
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [0,4,8,12,13,14,15]:
        # Swap the values.
        temp = new_state[index + 3]
        new_state[index + 3] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move, return None
        return None

def move_down_left_diagonal(state):
    """Moves the blank tile right on the board. Returns a new state as a list."""
    # Performs an object copy. Python passes by reference.
    new_state = state[:]
    index = new_state.index(0)
    # Sanity check
    if index not in [0,1,2,3,7,11,15]:
        # Swap the values.
        temp = new_state[index - 3]
        new_state[index - 3] = new_state[index]
        new_state[index] = temp
        return new_state
    else:
        # Can't move, return None
        return None
    
def create_node(state, parent, operator, depth, cost):
    return Node(state, parent, operator, depth, cost)


def expand_node(node):
    """Returns a list of expanded nodes"""
    expanded_nodes = []#new generation nodes
    expanded_nodes.append(create_node(move_up(node.state), node, "up", 1, 1))
    expanded_nodes.append(create_node(move_down(node.state), node, "down", 1, 1))
    expanded_nodes.append(create_node(move_left(node.state), node, "left", 1, 1))
    expanded_nodes.append(create_node(move_right(node.state), node, "right",  1, 1))
    
    expanded_nodes.append(create_node(move_up_left_diagonal(node.state), node, "upleft",  1, 4))
    expanded_nodes.append(create_node(move_down_left_diagonal(node.state), node, "downleft", 1, 4))
    expanded_nodes.append(create_node(move_up_right_diagonal(node.state), node, "upright",  1, 4))
    expanded_nodes.append(create_node(move_down_right_diagonal(node.state), node, "downright", 1, 4))
    # Filter the list and remove the nodes that are impossible (move function returned None)
    expanded_nodes = [node for node in expanded_nodes if node.state != None]  # list comprehension!
    return expanded_nodes

def uniform_cost(start,goal):
    num_of_expanded_nodes=0
    start_node=create_node(start,None,None,0,0)
    fringe=[]
    path=[]
    fringe.append(start_node)
    current=fringe.pop(0)
    print("root node state")
    print(current.state)
    print("-----------------")
    while(current.state!=goal):
        
        temp=expand_node(current)
        #number of total nodes
        num_of_expanded_nodes = num_of_expanded_nodes+len(temp)
        for item in temp:
            #nodes depth change have been expanded
            item.depth=item.depth+current.depth
            #nodes cost change depth have been expanded
            item.cost=item.cost + current.cost
            
            #expanding nodes are added to frontier list with previous generation nodes
            fringe.append(item)
    
      
        
        fringe.sort(key =lambda x: x.cost)
        
        current=fringe.pop(0)#less cost nodes choosen and remove from frontier list, then expanding is starting from this current-parent node
    print(" ")
    print("Total Number of Expanded Nodes")
    print(num_of_expanded_nodes)
    print(" ")
    print("--------------")
    print("Goal State")
    print("--------------")
    print(display_board(current.state))
    print("goal cost:")
    print(current.cost)
    print("goal depth:")
    print(current.depth)
   
    while(current.parent!=None):
        path.insert(0,current.operator)
        current=current.parent
    return path

# Node data structure
class Node:
    def __init__(self, state, parent, operator, depth, cost):
        # Contains the state of the node
        self.state = state
        # Contains the node that generated this node
        self.parent = parent
        # Contains the operation that generated this node from the parent
        self.operator = operator
        # Contains the depth of this node (parent.depth +1)
        self.depth = depth
        # Contains the path cost of this node from depth 0. 
        self.cost = cost
        

        self.heuristic=None





# Main method
def main():
    # 1,12,11,10,2,13,0,9,3,14,15,8,4,5,6,7
    starting_state = [ 1,12,11,10,2,13,8,9,3,14,15,0,4,5,6,7] #1 move instance
    print("root node state  representation")
    display_board(starting_state)
    ### CHANGE THIS FUNCTION TO USE 
    result = uniform_cost(starting_state, goal_state)
    if result == None:
        print( "No solution found")
    elif result == [None]:
        print( "Start node was the goal!")
    else:
        print(result)
        print(len(result), " moves")


# A python-isim. Basically if the file is being run execute the main() function.
if __name__ == "__main__":
    main()